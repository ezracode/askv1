<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TTS Button</title>
    <style>
        .tts-container {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 10px;
        }
        .tts-button {
            padding: 8px 15px;
            font-size: 14px;
            font-weight: 600;
            color: #ffffff;
            background-color: #3B82F6; /* blue-500 */
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.1s;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .tts-button:hover {
            background-color: #2563EB; /* blue-600 */
            transform: translateY(-1px);
        }
        .tts-button:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        .tts-button:disabled {
            background-color: #9CA3AF; /* gray-400 */
            cursor: not-allowed;
            box-shadow: none;
        }
        .icon {
            font-size: 16px;
        }
        .loading-spinner {
            border: 3px solid #f3f3f3;
            border-top: 3px solid #ffffff;
            border-radius: 50%;
            width: 14px;
            height: 14px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>

<div class="tts-container">
    <button id="ttsButton__KEY__" class="tts-button" onclick="playAudio__KEY__()">
        <span id="buttonIcon__KEY__" class="icon"></span>
        <span id="buttonText__KEY__">Leer Respuesta</span>
    </button>
</div>

<script>
    // --- Configuraci贸n de la API (Reemplazada por Python) ---
    const API_KEY_GLOBAL = ""; 
    const TTS_MODEL_NAME = '__TTS_MODEL_NAME__'; // gemini-2.5-flash-preview-tts
    const TTS_VOICE_NAME = '__TTS_VOICE_NAME__'; // Charon
    const API_URL = `https://generativelanguage.googleapis.com/v1beta/models/${TTS_MODEL_NAME}:generateContent?key=${API_KEY_GLOBAL}`;

    // --- Contenido espec铆fico de esta instancia de bot贸n (Reemplazado por Python) ---
    const TEXT_TO_SPEAK = __SAFE_TEXT__;
    const KEY = '__KEY__';

    // --- Referencias del DOM ---
    const button = document.getElementById(`ttsButton${KEY}`);
    const iconSpan = document.getElementById(`buttonIcon${KEY}`);
    const textSpan = document.getElementById(`buttonText${KEY}`);

    // --- Almacenamiento de audio (para evitar regenerar) ---
    let audioBlob = null;
    let audioContext = new (window.AudioContext || window.webkitAudioContext)();
    let audioSource = null;

    /**
     * Convierte la cadena base64 a un ArrayBuffer.
     * @param {string} base64 - Datos de audio PCM codificados en base64.
     * @returns {ArrayBuffer}
     */
    function base64ToArrayBuffer(base64) {
        const binaryString = atob(base64);
        const len = binaryString.length;
        const bytes = new Uint8Array(len);
        for (let i = 0; i < len; i++) {
            bytes[i] = binaryString.charCodeAt(i);
        }
        return bytes.buffer;
    }

    /**
     * Convierte audio PCM a formato WAV.
     * La API devuelve PCM de 16 bits firmado (L16).
     * @param {Int16Array} pcm16 - Array de 16-bit PCM samples.
     * @param {number} sampleRate - Tasa de muestreo (normalmente 24000).
     * @returns {Blob} - Blob de audio WAV.
     */
    function pcmToWav(pcm16, sampleRate) {
        const numChannels = 1;
        const bytesPerSample = 2; // 16-bit PCM

        const buffer = new ArrayBuffer(44 + pcm16.length * bytesPerSample);
        const view = new DataView(buffer);

        // RIFF chunk
        writeString(view, 0, 'RIFF');
        view.setUint32(4, 36 + pcm16.length * bytesPerSample, true);
        writeString(view, 8, 'WAVE');

        // fmt chunk
        writeString(view, 12, 'fmt ');
        view.setUint32(16, 16, true); // ChunkSize
        view.setUint16(20, 1, true); // AudioFormat (1 for PCM)
        view.setUint16(22, numChannels, true);
        view.setUint32(24, sampleRate, true);
        view.setUint32(28, sampleRate * numChannels * bytesPerSample, true); // ByteRate
        view.setUint16(32, numChannels * bytesPerSample, true); // BlockAlign
        view.setUint16(34, 16, true); // BitsPerSample

        // data chunk
        writeString(view, 36, 'data');
        view.setUint32(40, pcm16.length * bytesPerSample, true); // DataSize

        // Escribir los datos PCM
        let offset = 44;
        for (let i = 0; i < pcm16.length; i++, offset += 2) {
            view.setInt16(offset, pcm16[i], true);
        }

        return new Blob([buffer], { type: 'audio/wav' });

        function writeString(view, offset, string) {
            for (let i = 0; i < string.length; i++) {
                view.setUint8(offset + i, string.charCodeAt(i));
            }
        }
    }

    /**
     * Maneja el cambio de estado del bot贸n TTS.
     * @param {string} state - 'idle', 'loading', 'playing'
     */
    function setButtonState(state) {
        if (state === 'loading') {
            button.disabled = true;
            iconSpan.innerHTML = '<div class="loading-spinner"></div>';
            textSpan.textContent = 'Generando Voz...';
        } else if (state === 'playing') {
            button.disabled = false;
            iconSpan.textContent = '革';
            textSpan.textContent = 'Pausar';
        } else { // idle
            button.disabled = false;
            iconSpan.textContent = '';
            textSpan.textContent = 'Leer Respuesta';
        }
    }

    /**
     * Detiene la reproducci贸n de audio si est谩 activa.
     */
    function stopAudio() {
        if (audioSource) {
            audioSource.stop();
            audioSource = null;
        }
    }
    
    /**
     * Funci贸n principal que se llama al hacer clic en el bot贸n.
     */
    async function playAudio__KEY__() {
        if (audioSource) {
            // Caso 1: Est谩 reproduciendo -> Pausar/Detener
            stopAudio();
            setButtonState('idle');
            return;
        }

        if (audioBlob) {
            // Caso 2: Audio ya generado -> Reproducir
            await startPlayback();
            return;
        }
        
        // Caso 3: Audio no generado -> Generar y reproducir
        if (!API_KEY_GLOBAL) {
            alert("Error: La clave API de Google no est谩 configurada. El TTS no puede funcionar.");
            return;
        }

        setButtonState('loading');
        
        try {
            const payload = {
                contents: [{
                    parts: [{ text: `Say in a smooth, informative tone: ${TEXT_TO_SPEAK}` }]
                }],
                generationConfig: {
                    responseModalities: ["AUDIO"],
                    speechConfig: {
                        voiceConfig: {
                            prebuiltVoiceConfig: { voiceName: TTS_VOICE_NAME }
                        }
                    }
                },
                model: TTS_MODEL_NAME
            };

            // Implementaci贸n de Backoff Exponencial
            let response = null;
            let maxRetries = 5;
            let delay = 1000;
            
            for (let i = 0; i < maxRetries; i++) {
                try {
                    response = await fetch(API_URL, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (response.status !== 429) { // No es un error de Rate Limit
                        break; 
                    }
                } catch (error) {
                    console.error(`Fetch error (retry ${i + 1}):`, error);
                }

                if (i < maxRetries - 1) {
                    await new Promise(resolve => setTimeout(resolve, delay));
                    delay *= 2;
                } else {
                    throw new Error("M谩ximo de reintentos alcanzado.");
                }
            }
            
            if (!response || !response.ok) {
                const errorBody = await response.json();
                throw new Error(`API call failed with status ${response.status}: ${JSON.stringify(errorBody)}`);
            }

            const result = await response.json();
            const part = result?.candidates?.[0]?.content?.parts?.[0];
            const audioData = part?.inlineData?.data;
            const mimeType = part?.inlineData?.mimeType;

            if (audioData && mimeType && mimeType.startsWith("audio/L16")) {
                // La API devuelve audio/L16;rate=24000
                const sampleRateMatch = mimeType.match(/rate=(\d+)/);
                const sampleRate = sampleRateMatch ? parseInt(sampleRateMatch[1], 10) : 24000;
                
                const pcmData = base64ToArrayBuffer(audioData);
                const pcm16 = new Int16Array(pcmData);
                
                audioBlob = pcmToWav(pcm16, sampleRate);
                await startPlayback();
            } else {
                throw new Error("Respuesta de audio inv谩lida o datos de audio faltantes.");
            }

        } catch (error) {
            console.error("Error al generar o reproducir TTS:", error);
            setButtonState('idle');
            alert(`Error TTS: ${error.message}.`);
        }
    }

    /**
     * Inicia la reproducci贸n del Blob de audio ya generado.
     */
    async function startPlayback() {
        if (!audioBlob) return;
        
        setButtonState('playing');
        
        try {
            // Crea un ArrayBuffer desde el Blob
            const arrayBuffer = await audioBlob.arrayBuffer();
            
            // Decodifica el audio
            const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
            
            stopAudio(); // Asegura que no haya otra fuente activa
            
            audioSource = audioContext.createBufferSource();
            audioSource.buffer = audioBuffer;
            audioSource.connect(audioContext.destination);
            audioSource.start(0);

            // Manejar el evento de finalizaci贸n de la reproducci贸n
            audioSource.onended = () => {
                if (audioSource) {
                    setButtonState('idle');
                    audioSource = null;
                }
            };
        } catch (error) {
            console.error("Error al iniciar la reproducci贸n:", error);
            setButtonState('idle');
            alert(`Error de reproducci贸n: ${error.message}`);
        }
    }

    // Inicializar el estado del bot贸n al cargar
    document.addEventListener('DOMContentLoaded', () => {
        setButtonState('idle');
    });

</script>
</body>
</html>