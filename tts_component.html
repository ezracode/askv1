<div class="tts-container" data-tts-config='{}'>
    <button class="tts-button" onclick="handleButtonClick(this)">
        <span class="icon">
            <!-- Icono de altavoz/play (SVG) -->
            <svg class="h-5 w-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.536 8.464a5 5 0 010 7.072m2.828-9.9a9 9 0 010 12.728M5.586 15H3a1 1 0 01-1-1v-4a1 1 0 011-1h2.586l4.707-4.707A1 1 0 0113 4v16a1 1 0 01-1.707.707L5.586 15z" />
            </svg>
        </span>
        <span class="text">Leer Respuesta</span>
    </button>
    <span class="tts-status"></span>
</div>

<script>
    // --- Utilidades de AudioContext y Conversión (CRÍTICO para PCM) ---
    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
    let audioSource = null;
    let audioBlob = null;
    let buttonElement = null;
    let statusElement = null;
    let currentConfig = null;
    let currentStatus = 'idle';

    /**
     * Convierte una cadena Base64 a un ArrayBuffer.
     */
    function base64ToArrayBuffer(base64) {
        const binaryString = atob(base64);
        const len = binaryString.length;
        const bytes = new Uint8Array(len);
        for (let i = 0; i < len; i++) {
            bytes[i] = binaryString.charCodeAt(i);
        }
        return bytes.buffer;
    }

    /**
     * Convierte datos PCM (Int16Array) a un Blob de archivo WAV, añadiendo el encabezado RIFF.
     */
    function pcmToWav(pcmData, sampleRate) {
        const numChannels = 1;
        const bitsPerSample = 16;
        const byteRate = sampleRate * numChannels * (bitsPerSample / 8);
        const blockAlign = numChannels * (bitsPerSample / 8);
        
        // El tamaño total es 44 bytes para el encabezado + la longitud de los datos PCM
        const buffer = new ArrayBuffer(44 + pcmData.byteLength);
        const view = new DataView(buffer);
        let offset = 0;

        function writeString(view, offset, string) {
            for (let i = 0; i < string.length; i++) {
                view.setUint8(offset + i, string.charCodeAt(i));
            }
        }

        // RIFF chunk
        writeString(view, offset, 'RIFF'); offset += 4;
        view.setUint32(offset, 36 + pcmData.byteLength, true); offset += 4; // Tamaño del archivo
        writeString(view, offset, 'WAVE'); offset += 4;

        // FMT chunk
        writeString(view, offset, 'fmt '); offset += 4;
        view.setUint32(offset, 16, true); offset += 4; // Tamaño del sub-chunk
        view.setUint16(offset, 1, true); offset += 2; // Formato de audio (1 = PCM)
        view.setUint16(offset, numChannels, true); offset += 2; // Canales
        view.setUint32(offset, sampleRate, true); offset += 4; // Frecuencia de muestreo
        view.setUint32(offset, byteRate, true); offset += 4; // Byte rate
        view.setUint16(offset, blockAlign, true); offset += 2; // Block align
        view.setUint16(offset, bitsPerSample, true); offset += 2; // Bits por muestra

        // DATA chunk
        writeString(view, offset, 'data'); offset += 4;
        view.setUint32(offset, pcmData.byteLength, true); offset += 4; // Tamaño de los datos
        
        // Escribir los datos PCM (como Int16, little-endian)
        for (let i = 0; i < pcmData.length; i++) {
            view.setInt16(offset, pcmData[i], true); offset += 2;
        }

        return new Blob([view], { type: 'audio/wav' });
    }

    /**
     * Actualiza el estado visual del botón.
     */
    function setButtonState(state) {
        currentStatus = state;
        if (!buttonElement || !statusElement) return;

        buttonElement.disabled = (state === 'loading');
        
        const icon = buttonElement.querySelector('.icon');
        const text = buttonElement.querySelector('.text');

        if (state === 'loading') {
            text.textContent = 'Cargando...';
            icon.innerHTML = '<svg class="animate-spin h-5 w-5 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>';
        } else if (state === 'playing') {
            text.textContent = 'Detener';
            icon.innerHTML = '<svg class="h-5 w-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0zM9 10a1 1 0 012 0v4a1 1 0 11-2 0v-4zm4 0a1 1 0 012 0v4a1 1 0 11-2 0v-4z"/></svg>';
        } else { // idle
            text.textContent = 'Leer Respuesta';
            icon.innerHTML = '<svg class="h-5 w-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.536 8.464a5 5 0 010 7.072m2.828-9.9a9 9 0 010 12.728M5.586 15H3a1 1 0 01-1-1v-4a1 1 0 011-1h2.586l4.707-4.707A1 1 0 0113 4v16a1 1 0 01-1.707.707L5.586 15z" /></svg>';
        }
        statusElement.textContent = ''; 
    }

    /**
     * Detiene la reproducción de audio si está activa.
     */
    function stopAudio() {
        if (audioSource) {
            audioSource.stop();
            audioSource = null;
        }
    }

    /**
     * Inicia la generación TTS si no hay audio precargado, o reproduce el audio existente.
     */
    window.handleButtonClick = function(button) {
        // Inicializa los elementos si es la primera vez que se hace clic
        if (!buttonElement) {
             const container = button.closest('.tts-container');
             window.initTtsComponent(container);
        }

        if (currentStatus === 'playing') {
            stopAudio();
            setButtonState('idle');
            return;
        }

        if (audioBlob) {
            startPlayback();
        } else {
            generateTtsAudio();
        }
    }

    /**
     * Realiza la llamada a la API de TTS con reintento (Exponential Backoff).
     */
    async function generateTtsAudio(retryCount = 0) {
        if (!currentConfig || !currentConfig.text) return;
        
        setButtonState('loading');
        audioBlob = null; 
        
        const maxRetries = 3;
        const delay = Math.pow(2, retryCount) * 1000; 

        const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${currentConfig.model}:generateContent?key=${currentConfig.api_key}`;
        
        const payload = {
            contents: [{ parts: [{ text: currentConfig.text }] }],
            generationConfig: {
                responseModalities: ["AUDIO"],
                speechConfig: {
                    voiceConfig: {
                        prebuiltVoiceConfig: { voiceName: currentConfig.voice }
                    }
                }
            },
        };

        try {
            await new Promise(resolve => setTimeout(resolve, delay));

            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`API response error: ${response.status} - ${errorText}`);
            }

            const result = await response.json();
            const candidate = result?.candidates?.[0];
            const part = candidate?.content?.parts?.[0];
            const audioData = part?.inlineData?.data;
            const mimeType = part?.inlineData?.mimeType;

            // Extraer el sample rate del grounding metadata o del MIME type
            let sampleRate = 24000; // Valor por defecto
            const groundingMetadata = candidate?.groundingMetadata;
            if (groundingMetadata && groundingMetadata.audioMetadata && groundingMetadata.audioMetadata.sampleRateHertz) {
                sampleRate = groundingMetadata.audioMetadata.sampleRateHertz;
            } else {
                 // Intentar obtener el sample rate del MIME type como fallback
                const rateMatch = mimeType ? mimeType.match(/rate=(\d+)/) : null;
                if (rateMatch && rateMatch.length >= 2) {
                    sampleRate = parseInt(rateMatch[1], 10);
                } else {
                    console.warn("Could not retrieve sample rate. Using default: 24000 Hz.");
                }
            }


            if (audioData && mimeType && mimeType.startsWith("audio/L16")) {
                // Conversión CRÍTICA de PCM a WAV para reproducción
                const pcmDataBuffer = base64ToArrayBuffer(audioData);
                const pcm16 = new Int16Array(pcmDataBuffer);
                audioBlob = pcmToWav(pcm16, sampleRate);
                
                startPlayback();
            } else {
                throw new Error(`Invalid audio data or unexpected MIME type: ${mimeType}`);
            }
        } catch (error) {
            console.error("Error generating TTS:", error);
            if (retryCount < maxRetries) {
                statusElement.textContent = `Error. Retrying (${retryCount + 1})...`;
                await generateTtsAudio(retryCount + 1); 
            } else {
                setButtonState('idle');
                // Alerta genérica en español
                alert(`Error TTS: Fallo después de ${maxRetries} intentos. El servicio de voz no responde o el audio es inválido.`);
            }
        }
    }

    /**
     * Inicia la reproducción del Blob de audio ya generado.
     */
    async function startPlayback() {
        if (!audioBlob) return;
        
        setButtonState('playing');
        stopAudio(); 
        
        try {
            const arrayBuffer = await audioBlob.arrayBuffer();
            const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
            
            audioSource = audioContext.createBufferSource();
            audioSource.buffer = audioBuffer;
            audioSource.connect(audioContext.destination);
            audioSource.start(0);

            audioSource.onended = () => {
                if (currentStatus === 'playing') { 
                    setButtonState('idle');
                }
                audioSource = null;
            };
        } catch (error) {
            console.error("Error starting playback:", error);
            setButtonState('idle');
            // Alerta genérica en español
            alert(`Error de reproducción: El navegador no puede decodificar el audio. ${error.message}`);
        }
    }

    /**
     * Función de inicialización expuesta globalmente.
     */
    window.initTtsComponent = function(container) {
        if (!container) return;
        
        buttonElement = container.querySelector('.tts-button');
        statusElement = container.querySelector('.tts-status');
        
        const configData = container.getAttribute('data-tts-config');
        if (configData) {
            try {
                currentConfig = JSON.parse(configData);
            } catch (e) {
                console.error("Error parsing TTS configuration:", e);
                currentConfig = null;
            }
        }
        
        setButtonState('idle');
        audioBlob = null; 
    };
</script>

<style>
    .tts-container {
        display: flex;
        align-items: center;
        gap: 10px;
        margin-top: 10px;
        font-family: 'Inter', sans-serif;
    }
    .tts-button {
        padding: 8px 15px;
        font-size: 14px;
        font-weight: 600;
        color: #ffffff;
        background-color: #3B82F6; /* blue-500 */
        border: none;
        border-radius: 8px;
        cursor: pointer;
        transition: background-color 0.2s, transform 0.1s;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        display: flex;
        align-items: center;
        gap: 5px;
    }
    .tts-button:hover {
        background-color: #2563EB; /* blue-600 */
        transform: translateY(-1px);
    }
    .tts-button:active {
        transform: translateY(0);
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }
    .tts-button:disabled {
        background-color: #9CA3AF; /* gray-400 */
        cursor: not-allowed;
    }
    .tts-status {
        font-size: 12px;
        color: #EF4444; /* red-500 */
    }
</style>